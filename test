#include "translator.h"

int CompleteElf_ident(Text* buffer)
{
        buffer->str[0] = 0x7f;
        buffer->str[1] = 0x45;
        buffer->str[2] = 0x4c;
        buffer->str[3] = 0x46;

        buffer->str[4] = 0x02;          // EI_CLASS - x64
        buffer->str[5] = 0x01;          // EI_DATA - little endian
        buffer->str[6] = 0x01;          // EI_VERSION - 1

        for (size_t i = 7; i < 15; i++)
                buffer->str[i] = 0x00;
        
        buffer->str[15] = 0x10;

        return 0;
}

int CompleteElf_type(Text* buffer)      // исполняемый файл ELF
{
        buffer->str[16] = 0x02;         // ET_EXEC
        buffer->str[17] = 0x00;

        return 0;
}

int CompleteElf_machine(Text* buffer)   // для работы на процессорах типа i386
{
        buffer->str[18] = 0x03;
        buffer->str[19] = 0x00;

        return 0;
}

int CompleteElf_version(Text* buffer)   // по умолчанию
{
        buffer->str[20] = 0x01;
        buffer->str[21] = 0x00;
        buffer->str[22] = 0x00;
        buffer->str[23] = 0x00;

        return 0;
}

int CompleteElf_entry(Text* buffer)     // абсолютный виртуальный адрес начала выполнения программы
{                                       // !
        buffer->str[24] = 0x80;
        buffer->str[25] = 0x80;
        buffer->str[26] = 0x04;
        buffer->str[27] = 0x08;

        buffer->str[28] = 0x00;
        buffer->str[29] = 0x00;
        buffer->str[30] = 0x00;
        buffer->str[31] = 0x00;

        return 0;
}

int CompleteElf_phoff(Text* buffer)     // смещение от файла к program header table
{
        buffer->str[32] = 0x34;
        buffer->str[33] = 0x00;
        buffer->str[34] = 0x00;
        buffer->str[35] = 0x00;

        buffer->str[36] = 0x00;
        buffer->str[37] = 0x00;
        buffer->str[38] = 0x00;
        buffer->str[39] = 0x00;

        return 0;
}

int CompleteElf_shoff(Text* buffer)     // смещение от начала файла к таблице заголовков раздела
{
        buffer->str[40] = 0x00;
        buffer->str[41] = 0x00;
        buffer->str[42] = 0x00;
        buffer->str[43] = 0x00;

        buffer->str[44] = 0x00;
        buffer->str[45] = 0x00;
        buffer->str[46] = 0x00;
        buffer->str[47] = 0x00;

        return 0;
}

int CompleteElf_flags(Text* buffer)
{
        buffer->str[48] = 0x00;
        buffer->str[49] = 0x00;
        buffer->str[50] = 0x00;
        buffer->str[51] = 0x00;

        return 0;
}

int CompleteElf_ehsize(Text* buffer)    // размер заголовка ELF
{
        buffer->str[52] = 0x40;
        buffer->str[53] = 0x00;

        return 0;
}


int CompleteElf_phentsize(Text* buffer) // размер заголовка программы
{
        buffer->str[54] = 0x20;
        buffer->str[55] = 0x00;

        return 0;
}

int CompleteElf_phnum(Text* buffer)     // количество заголовков программы .text и .data
{
        buffer->str[56] = 0x02;
        buffer->str[57] = 0x00;

        return 0;
}

int CompleteElf_shentsize(Text* buffer)
{
        buffer->str[58] = 0x00;
        buffer->str[59] = 0x00;

        return 0;
}

int CompleteElf_shnum(Text* buffer)
{
        buffer->str[60] = 0x00;
        buffer->str[61] = 0x00;

        return 0;
}

int CompleteElf_shstrndx(Text* buffer)
{
        buffer->str[62] = 0x00;
        buffer->str[63] = 0x00;

        return 0;
}

int CompleteElfHeader(Text* buffer)
{
        // typedef struct {
        //         unsigned char e_ident[16];      /* Магическое число и другая информация */
        //         uint16_t e_type;                /* Тип объектного файла */
        //         uint16_t e_machine;             /* Архитектура */
        //         uint32_t e_version;             /* Версия объектного файла */
        //         uint64_t e_entry;               /* Виртуальный адрес точки входа */
        //         uint64_t e_phoff;               /* Смещение таблицы заголовков программы в файле */
        //         uint64_t e_shoff;               /* Смещение таблицы заголовков секций в файле */
        //         uint32_t e_flags;               /* Флаги, зависящие от процессора */
        //         uint16_t e_ehsize;              /* Размер заголовка ELF в байтах */
        //         uint16_t e_phentsize;           /* Размер записи таблицы заголовков программы */
        //         uint16_t e_phnum;               /* Количество записей в таблице заголовков программы */
        //         uint16_t e_shentsize;           /* Размер записи таблицы заголовков секций */
        //         uint16_t e_shnum;               /* Количество записей в таблице заголовков секций */
        //         uint16_t e_shstrndx;            /* Индекс таблицы строк в заголовке секции */
        // } Elf64_Ehdr;

        CompleteElf_ident(buffer);
        CompleteElf_type(buffer);
        CompleteElf_machine(buffer);
        CompleteElf_version(buffer);

        CompleteElf_entry(buffer);
        CompleteElf_phoff(buffer);
        CompleteElf_shoff(buffer);
        CompleteElf_flags(buffer);
        CompleteElf_ehsize(buffer);

        
        CompleteElf_phentsize(buffer);
        CompleteElf_phnum(buffer);

        CompleteElf_shentsize(buffer);
        CompleteElf_shnum(buffer);
        CompleteElf_shstrndx(buffer);

        return 0;
}


int CompleteTextP_type(Text* buffer)
{
        buffer->str[64] = 0x01; // PT_LOAD
        buffer->str[65] = 0x00;
        buffer->str[66] = 0x00;
        buffer->str[67] = 0x00;

        return 0;
}

int CompleteTextP_offset(Text* buffer)      // смещение от начала файла
{                                           // !
        buffer->str[68] = 0x80;
        buffer->str[69] = 0x00;
        buffer->str[70] = 0x00;
        buffer->str[71] = 0x00;
        buffer->str[72] = 0x80;
        buffer->str[73] = 0x00;
        buffer->str[74] = 0x00;
        buffer->str[75] = 0x00;

        return 0;
}

int CompleteTextP_vaddr(Text* buffer)   // виртуальный адрес
{                                       // !
        buffer->str[76] = 0x80;
        buffer->str[77] = 0x80;
        buffer->str[78] = 0x04;
        buffer->str[79] = 0x08;

        buffer->str[80] = 0x00;
        buffer->str[81] = 0x00;
        buffer->str[82] = 0x00;
        buffer->str[83] = 0x00;

        return 0;
}


int CompleteTextP_paddr(Text* buffer)   // физическая адресация
{
        buffer->str[84] = 0x00;
        buffer->str[85] = 0x00;
        buffer->str[86] = 0x00;
        buffer->str[87] = 0x00;

        buffer->str[88] = 0x00;
        buffer->str[89] = 0x00;
        buffer->str[90] = 0x00;
        buffer->str[91] = 0x00;

        return 0;
}

int CompleteTextP_filesz(Text* buffer)  // количество байтов в образе файла сегмента
{                                       // !
        buffer->str[92] = 0x24;
        buffer->str[93] = 0x00;
        buffer->str[94] = 0x00;
        buffer->str[95] = 0x00;

        return 0;
}

int CompleteTextP_memsz(Text* buffer)   // количество байтов в памяти образа сегмента
{                                       // !
        buffer->str[96] = 0x24;
        buffer->str[97] = 0x00;
        buffer->str[98] = 0x00;
        buffer->str[99] = 0x00;

        return 0;
}

int CompleteTextP_flags(Text* buffer)       // READ - 0x04, WRITE - 0x02, EXEC - 0x01
{
        buffer->str[100] = 0x05;
        buffer->str[101] = 0x00;
        buffer->str[102] = 0x00;
        buffer->str[103] = 0x00;

        return 0;
}

int CompleteTextP_align(Text* buffer)       // указывает на выравнивание страниц памяти
{
        buffer->str[104] = 0x00;
        buffer->str[105] = 0x10;
        buffer->str[106] = 0x00;
        buffer->str[107] = 0x00;

        return 0;
}

//---------------------------------------------------------------------------------------



int CompleteDataP_type(Text* buffer)
{
        buffer->str[108] = 0x01; // PT_LOAD
        buffer->str[109] = 0x00;
        buffer->str[110] = 0x00;
        buffer->str[111] = 0x00;

        return 0;
}

int CompleteDataP_offset(Text* buffer)  // смещение от начала файла
{                                       // !
        buffer->str[112] = 0xA4;
        buffer->str[113] = 0x00;
        buffer->str[114] = 0x00;
        buffer->str[115] = 0x00;
        buffer->str[116] = 0x00;
        buffer->str[117] = 0x00;
        buffer->str[118] = 0x00;
        buffer->str[119] = 0x00;

        return 0;
}

int CompleteDataP_vaddr(Text* buffer)   // виртуальный адрес
{                                       // !
        buffer->str[120] = 0xA4;
        buffer->str[121] = 0x80;
        buffer->str[122] = 0x04;
        buffer->str[123] = 0x08;
        buffer->str[124] = 0x00;
        buffer->str[125] = 0x00;
        buffer->str[126] = 0x00;
        buffer->str[127] = 0x00;

        return 0;
}


int CompleteDataP_paddr(Text* buffer)       // физическая адресация
{
        buffer->str[128] = 0x00;
        buffer->str[129] = 0x00;
        buffer->str[130] = 0x00;
        buffer->str[131] = 0x00;
        buffer->str[132] = 0x00;
        buffer->str[133] = 0x00;
        buffer->str[134] = 0x00;
        buffer->str[135] = 0x00;

        return 0;
}
 
int CompleteDataP_filesz(Text* buffer)  // количество байтов в образе файла сегмента
{                                       // !
        buffer->str[136] = 0x20;
        buffer->str[137] = 0x00;
        buffer->str[138] = 0x00;
        buffer->str[139] = 0x00;

        return 0;
}

int CompleteDataP_memsz(Text* buffer)       // количество байтов в памяти образа сегмента
{                                       // !
        buffer->str[140] = 0x20;
        buffer->str[141] = 0x00;
        buffer->str[142] = 0x00;
        buffer->str[143] = 0x00;

        return 0;
}

int CompleteDataP_flags(Text* buffer)       // READ - 0x04, WRITE - 0x02, EXEC - 0x01
{
        buffer->str[144] = 0x07;
        buffer->str[145] = 0x00;
        buffer->str[146] = 0x00;
        buffer->str[147] = 0x00;

        return 0;
}

int CompleteDataP_align(Text* buffer)       // указывает на выравнивание страниц памяти
{
        buffer->str[148] = 0x00;
        buffer->str[149] = 0x10;
        buffer->str[150] = 0x00;
        buffer->str[151] = 0x00;

        return 0;
}
// 00 00 00 00 00 00 00 00 00 00 00 00
        



int CompleteProgramHeaderTable(Text* buffer)
{

        CompleteTextP_type(buffer);
        CompleteTextP_offset(buffer);
        CompleteTextP_vaddr(buffer);
        CompleteTextP_paddr(buffer);
        CompleteTextP_filesz(buffer);
        CompleteTextP_memsz(buffer);
        CompleteTextP_flags(buffer);
        CompleteTextP_align(buffer);


        
        CompleteDataP_type(buffer);
        CompleteDataP_offset(buffer);
        CompleteDataP_vaddr(buffer);
        CompleteDataP_paddr(buffer);
        CompleteDataP_filesz(buffer);
        CompleteDataP_memsz(buffer);
        CompleteDataP_flags(buffer);
        CompleteDataP_align(buffer);
        
        return 0;
}

int TranslateToELF(Text* buffer, Tree** tree, err_allocator* err_alloc)
{
        CompleteElfHeader(buffer);
        CompleteProgramHeaderTable(buffer);
        
        buffer->position = 152;

        CompleteText(buffer);
        CompleteData(buffer);

        printf("%lu\n", buffer->position);
        ReallocateBuffer(buffer, buffer->position, err_alloc);

        // 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 10 02 00 03 00
        // 01 00 00 00 80 80 04 08 34 00 00 00 00 00 00 00 00 00 00 00
        // 34 00 20 00 02 00 00 00 00 00 00 00 
        //                                     01 00 00 00 80 00 00 00
        // 80 80 04 08 00 00 00 00 24 00 00 00 24 00 00 00 05 00 00 00
        // 00 10 00 00 
        //             01 00 00 00 A4 00 00 00 A4 80 04 08 00 00 00 00
        // 20 00 00 00 20 00 00 00 07 00 00 00 00 10 00 00 
        //
        // 00 00 00 00 00 00 00 00 00 00 00 00 
        //                         BB 01 00 00 00 B8 04 00 00 00 B9 A4
        // 80 04 08 BA 0D 00 00 00 CD 80 B8 01 00 00 00 BB 2A 00 00 00
        // CD 80 
        //       00 00 
        //             48 65 6C 6C 6F 20 57 6F 72 6C 64 21 0A


        return 0;
}


int CompleteText(Text* buffer)
{
        char* buf = buffer->str + buffer->position;

        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        
        *(buf++) = 0xBB;
        *(buf++) = 0x01;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0xB8;
        *(buf++) = 0x04;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0xB9;
        *(buf++) = 0xA4;
        *(buf++) = 0x80;
        *(buf++) = 0x04;
        *(buf++) = 0x08;
        *(buf++) = 0xBA;
        *(buf++) = 0x0D;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0xCD;
        *(buf++) = 0x80;


        *(buf++) = 0xB8;
        *(buf++) = 0x01;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0xBB;
        *(buf++) = 0x2A;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0x00;
        *(buf++) = 0xCD;
        *(buf++) = 0x80;

        *(buf++) = 0x00;
        *(buf++) = 0x00;

        buffer->position = (size_t) (buf - buffer->str);
        printf("%lu\n", buffer->position);

        // 0xBB 0x01 0x00 0x00 0x00
        // 0xB8 0x04 0x00 0x00 0x00
        // 0xB9 0x** 0x** 0x** 0x**
        // 0xBA 0x0D 0x00 0x00 0x00
        // 0xCD 0x80
        // 
        // 0xB8 0x01 0x00 0x00 0x00
        // 0xBB 0x5D 0x00 0x00 0x00
        // 0xCD 0x80

        return 0;
}

int CompleteData(Text* buffer)
{
        char* buf = buffer->str + buffer->position;

        *(buf++) = 0x48;
        *(buf++) = 0x65;
        *(buf++) = 0x6C;
        *(buf++) = 0x6C;
        *(buf++) = 0x6F;
        *(buf++) = 0x20;
        *(buf++) = 0x57;
        *(buf++) = 0x6F;
        *(buf++) = 0x72;
        *(buf++) = 0x6C;
        *(buf++) = 0x64;
        *(buf++) = 0x21;
        *(buf++) = 0x0A;
        
        buffer->position = (size_t) (buf - buffer->str);

        // 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64 0x21 0x0A

        return 0;
}



int Verificator(Text* buffer, Tree** tree, err_allocator* err_alloc)
{
        if (buffer->str[0] != 0)
                //error

        if (buffer->str[1] != 0)
                //error

        if (buffer->str[2] != 0)
                //error


        // buffer->str[0] = 0x7c;
        // buffer->str[1] = 0x45;
        // buffer->str[2] = 0x4c;
        // buffer->str[3] = 0x46;

        // buffer->str[4] = 0x02;
        // buffer->str[5] = 0x01;
        // buffer->str[6] = 0x01;

        // for (size_t i = 7; i < 15; i++)
        //         buffer->str[i] = 0x00;
        
        // buffer->str[15] = 0x10;


        // buffer->str[16] = 0x02;
        // buffer->str[17] = 0x00;

        // buffer->str[18] = 0x03;
        // buffer->str[19] = 0x00;

        // buffer->str[20] = 0x01;
        // buffer->str[21] = 0x00;
        // buffer->str[22] = 0x00;
        // buffer->str[23] = 0x00;

        // // !
        // buffer->str[24] = 0x80;
        // buffer->str[25] = 0x80;
        // buffer->str[26] = 0x04;
        // buffer->str[27] = 0x08;

        // buffer->str[28] = 0x34;
        // buffer->str[29] = 0x00;
        // buffer->str[30] = 0x00;
        // buffer->str[31] = 0x00;
        
        // //!!
        // buffer->str[32] = 0x00;
        // buffer->str[33] = 0x00;
        // buffer->str[34] = 0x00;
        // buffer->str[35] = 0x00;

        // buffer->str[36] = 0x00;
        // buffer->str[37] = 0x00;
        // buffer->str[38] = 0x00;
        // buffer->str[39] = 0x00;

        // buffer->str[40] = 0x34;
        // buffer->str[41] = 0x00;

        // //!
        // buffer->str[42] = 0x20;
        // buffer->str[43] = 0x00;

        // buffer->str[44] = 0x02;
        // buffer->str[45] = 0x00;

        // buffer->str[46] = 0x00;
        // buffer->str[47] = 0x00;

        // buffer->str[48] = 0x00;
        // buffer->str[49] = 0x00;

        // buffer->str[50] = 0x00;
        // buffer->str[51] = 0x00;


        // buffer->str[52] = 0x01;
        // buffer->str[53] = 0x00;
        // buffer->str[54] = 0x00;
        // buffer->str[55] = 0x00;

        // // !
        // buffer->str[56] = 0x80;
        // buffer->str[57] = 0x00;
        // buffer->str[58] = 0x00;
        // buffer->str[59] = 0x00;

        // // !
        // buffer->str[60] = 0x80;
        // buffer->str[61] = 0x80;
        // buffer->str[62] = 0x04;
        // buffer->str[63] = 0x08;

        // buffer->str[64] = 0x00;
        // buffer->str[65] = 0x00;
        // buffer->str[66] = 0x00;
        // buffer->str[67] = 0x00;

        // // !
        // buffer->str[68] = 0x24;
        // buffer->str[69] = 0x00;
        // buffer->str[70] = 0x00;
        // buffer->str[71] = 0x00;

        // // !
        // buffer->str[72] = 0x24;
        // buffer->str[73] = 0x00;
        // buffer->str[74] = 0x00;
        // buffer->str[75] = 0x00;

        // // !
        // buffer->str[76] = 0x05;
        // buffer->str[77] = 0x00;
        // buffer->str[78] = 0x00;
        // buffer->str[79] = 0x00;

        // buffer->str[80] = 0x00;
        // buffer->str[81] = 0x10;
        // buffer->str[82] = 0x00;
        // buffer->str[83] = 0x00;


        // buffer->str[84] = 0x01; 
        // buffer->str[85] = 0x00;
        // buffer->str[86] = 0x00;
        // buffer->str[87] = 0x00;
        //                     // !
        // buffer->str[88] = 0xA4;
        // buffer->str[89] = 0x00;
        // buffer->str[90] = 0x00;
        // buffer->str[91] = 0x00;

        //                                // !
        // buffer->str[92] = 0xA4;
        // buffer->str[93] = 0x80;
        // buffer->str[94] = 0x04;
        // buffer->str[95] = 0x08;

        // buffer->str[96] = 0x00;
        // buffer->str[97] = 0x00;
        // buffer->str[98] = 0x00;
        // buffer->str[99] = 0x00;
        //                         // !
        // buffer->str[100] = 0x20;
        // buffer->str[101] = 0x00;
        // buffer->str[102] = 0x00;
        // buffer->str[103] = 0x00;
        //                               // !
        // buffer->str[104] = 0x20;
        // buffer->str[105] = 0x00;
        // buffer->str[106] = 0x00;
        // buffer->str[107] = 0x00;

        // buffer->str[108] = 0x07;
        // buffer->str[109] = 0x00;
        // buffer->str[110] = 0x00;
        // buffer->str[111] = 0x00;
        
        // buffer->str[112] = 0x00;
        // buffer->str[113] = 0x10;
        // buffer->str[114] = 0x00;
        // buffer->str[115] = 0x00;

        return 0;
}
